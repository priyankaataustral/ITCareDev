# Safe Flask-Migrate Guide for Escalation Summary Feature

## ‚ö†Ô∏è **IMPORTANT: Schema Mismatch Prevention**

Since you've made manual changes in MySQL Workbench, we need to ensure Flask-Migrate doesn't conflict with your current database state.

## üîç **Step 1: Check Current Database State**

First, let's audit your current database to understand what manual changes exist:

```sql
-- Run these in MySQL Workbench to check current schema
USE tickets;

-- Check if escalation_summaries table already exists
SHOW TABLES LIKE 'escalation_summaries';

-- Check current table structures that might have changed
DESCRIBE tickets;
DESCRIBE agents;
DESCRIBE departments;
DESCRIBE messages;
DESCRIBE kb_articles;

-- Check for any custom indexes or constraints you've added
SHOW INDEXES FROM tickets;
SHOW INDEXES FROM agents;
SHOW INDEXES FROM departments;
```

## üõ°Ô∏è **Step 2: Backup Your Database**

**CRITICAL: Always backup before migration!**

```bash
# Create backup
mysqldump -u your_username -p tickets > backup_before_escalation_migration.sql

# Or if using Azure MySQL
mysqldump -h ai-sql-dev.mysql.database.azure.com -u dbadmin -p tickets > backup_before_escalation_migration.sql
```

## üìã **Step 3: Review Your models.py**

Your `models.py` looks good! I can see the `EscalationSummary` model is already properly defined. However, let me check a few potential issues:

### Issues Found & Fixes Needed:

1. **SQLiteJSON in MySQL**: Line 196 and 226 use `SQLiteJSON` which won't work with MySQL
2. **Text collation**: Line 196 has MySQL-specific collation that should be in model definition
3. **Mixed datetime types**: Some use `timezone=True`, others don't

‚úÖ **Fixed these issues in models.py:**
1. Changed `SQLiteJSON` to `JSON` for MySQL compatibility
2. Removed MySQL-specific collation from model (handled at database level)
3. Standardized datetime columns to use `timezone=True`
4. Fixed default values to use timezone-aware datetime

## üîß **Step 4: Generate Migration Safely**

Now let's generate the migration for the escalation feature:

```bash
# Navigate to backend directory
cd backend

# Activate your virtual environment if needed
# source venv/bin/activate  # or venv\Scripts\activate on Windows

# Generate migration for escalation_summaries table
flask --app app:create_app db migrate -m "Add escalation_summaries table"
```

## üîç **Step 5: Review Generated Migration**

**CRITICAL:** Always review the generated migration file before applying it!

The migration file will be in `migrations/versions/` with a name like `xxxx_add_escalation_summaries_table.py`

### Check for these potential issues:

1. **Conflicting changes**: If Flask-Migrate detects differences between your models and current DB
2. **Missing tables**: Ensure it only creates `escalation_summaries`, not trying to recreate existing tables
3. **Data type mismatches**: Verify MySQL data types are correct

### Example of what the migration should look like:

```python
"""Add escalation_summaries table

Revision ID: abc123
Revises: def456
Create Date: 2024-01-XX XX:XX:XX.XXXXXX

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers
revision = 'abc123'
down_revision = 'def456'  # Previous migration
branch_labels = None
depends_on = None

def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('escalation_summaries',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('ticket_id', sa.String(length=45), nullable=False),
    sa.Column('escalated_to_department_id', sa.Integer(), nullable=True),
    sa.Column('escalated_to_agent_id', sa.Integer(), nullable=True),
    sa.Column('escalated_by_agent_id', sa.Integer(), nullable=True),
    sa.Column('reason', sa.Text(), nullable=False),
    sa.Column('summary_note', sa.Text(), nullable=True),
    sa.Column('from_level', sa.Integer(), nullable=False),
    sa.Column('to_level', sa.Integer(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('read_by_agent_id', sa.Integer(), nullable=True),
    sa.Column('read_at', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['escalated_by_agent_id'], ['agents.id'], ),
    sa.ForeignKeyConstraint(['escalated_to_agent_id'], ['agents.id'], ),
    sa.ForeignKeyConstraint(['escalated_to_department_id'], ['departments.id'], ),
    sa.ForeignKeyConstraint(['read_by_agent_id'], ['agents.id'], ),
    sa.ForeignKeyConstraint(['ticket_id'], ['tickets.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###

def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('escalation_summaries')
    # ### end Alembic commands ###
```

## ‚ö†Ô∏è **Step 6: Handle Schema Mismatches**

If Flask-Migrate detects unexpected differences (due to your manual changes), you have several options:

### Option A: Mark Database as Current (Recommended)
If you're confident your manual changes are correct:

```bash
# Mark the current database state as up-to-date with models
flask --app app:create_app db stamp head

# Then generate only the escalation_summaries migration
flask --app app:create_app db migrate -m "Add escalation_summaries table"
```

### Option B: Manually Edit Migration
If the auto-generated migration includes unwanted changes:

1. Edit the migration file to remove unwanted operations
2. Keep only the `escalation_summaries` table creation
3. Test the migration on a backup first

### Option C: Create Manual Migration
Create a custom migration file with only the escalation table:

```bash
# Create empty migration
flask --app app:create_app db revision -m "Add escalation_summaries table"
# Then manually edit the file with only the escalation table creation
```

## üöÄ **Step 7: Apply Migration**

Once you've reviewed and are satisfied with the migration:

```bash
# Apply the migration
flask --app app:create_app db upgrade

# Verify it worked
flask --app app:create_app db current
```

## ‚úÖ **Step 8: Verify Migration Success**

```sql
-- In MySQL Workbench, verify the table was created correctly
USE tickets;
DESCRIBE escalation_summaries;
SHOW CREATE TABLE escalation_summaries;

-- Test basic functionality
INSERT INTO escalation_summaries 
(ticket_id, reason, from_level, to_level) 
VALUES ('TEST001', 'Test escalation', 1, 2);

SELECT * FROM escalation_summaries;
DELETE FROM escalation_summaries WHERE ticket_id = 'TEST001';
```

## üõü **Rollback Plan**

If something goes wrong:

```bash
# Rollback the migration
flask --app app:create_app db downgrade

# Or restore from backup
mysql -u your_username -p tickets < backup_before_escalation_migration.sql
```

## üìù **Final Checklist**

- [ ] Database backed up
- [ ] Current schema documented
- [ ] Migration file reviewed
- [ ] Test environment verified
- [ ] Rollback plan ready
- [ ] Team notified (if applicable)

## üéØ **Best Practices for Future**

1. **Always use Flask-Migrate**: Avoid manual schema changes in production
2. **Test migrations**: Use a copy of production data for testing
3. **Review migrations**: Never blindly run auto-generated migrations
4. **Document changes**: Keep notes on any manual database modifications
5. **Use staging**: Test migrations in staging environment first

This approach ensures your escalation feature is safely deployed without breaking your existing database!
